"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Client = exports.ResopnseFlags = exports.FortniteAPIError = exports.Endpoints = void 0;
const endpoints_js_1 = require("./endpoints.js");
__exportStar(require("./types.js"), exports);
var endpoints_js_2 = require("./endpoints.js");
Object.defineProperty(exports, "Endpoints", { enumerable: true, get: function () { return endpoints_js_2.Endpoints; } });
/**
 * An error thrown when Fortnite-API responds with a non-200 status
 */
class FortniteAPIError extends Error {
    /**
     * The error's status code
     */
    code;
    /**
     * The URL which threw the error
     */
    route;
    constructor(error, route) {
        super(error.error);
        this.name = 'FortniteAPIError';
        this.code = error.status;
        this.route = route;
    }
}
exports.FortniteAPIError = FortniteAPIError;
var ResopnseFlags;
(function (ResopnseFlags) {
    ResopnseFlags[ResopnseFlags["None"] = 0] = "None";
    ResopnseFlags[ResopnseFlags["IncludePaths"] = 1] = "IncludePaths";
    ResopnseFlags[ResopnseFlags["IncludeGameplayTags"] = 2] = "IncludeGameplayTags";
    ResopnseFlags[ResopnseFlags["IncludeShopHistory"] = 4] = "IncludeShopHistory";
})(ResopnseFlags = exports.ResopnseFlags || (exports.ResopnseFlags = {}));
/**
 * A class whose methods fetch data from Fortnite-API
 */
class Client {
    /**
     * The API key to use when calling Client#stats()
     */
    key;
    /**
     * The default language to use for all applicable methods
     */
    language;
    constructor(options = {}) {
        this.key = options.key ?? null;
        this.language = options.language ?? 'en';
    }
    route(endpoint, params = {}, hasArray = false) {
        if (!hasArray) {
            return `${endpoint}?${new URLSearchParams(Object.entries(params))}`;
        }
        return Object.keys(params).length === 0
            ? endpoint
            : `${endpoint}?${Object.entries(params).map(([key, value]) => Array.isArray(value) ? value.map(v => `${key}=${v}`).join('&') : `${key}=${value}`).join('&')}`;
    }
    async fetch(route, key) {
        const res = await fetch(route, key !== undefined ? { headers: { Authorization: key } } : undefined).then(r => r.json());
        if ('error' in res)
            throw new FortniteAPIError(res, route);
        return res.data;
    }
    parseFlags(options) {
        let responseFlags = ResopnseFlags.None;
        if (options.includePaths)
            responseFlags |= ResopnseFlags.IncludePaths;
        if (options.includeGameplayTags)
            responseFlags |= ResopnseFlags.IncludeGameplayTags;
        if (options.includeShopHistory)
            responseFlags |= ResopnseFlags.IncludeShopHistory;
        return responseFlags;
    }
    /**
     * Fetches the current AES key.
     *
     * @param keyFormat - The AES key's format
     * @returns Information about the current AES key
     */
    aes(keyFormat = 'hex') {
        return this.fetch(this.route(endpoints_js_1.Endpoints.AES, { keyFormat }));
    }
    /**
     * Fetches all banners.
     *
     * @param language - The language for the returned data
     * @returns An array of every banner
     */
    banners(language = this.language) {
        return this.fetch(this.route(endpoints_js_1.Endpoints.Banners, { language }));
    }
    /**
     * Fetches all banner colors.
     *
     * @returns An array of every banner color
     */
    bannerColors() {
        return this.fetch(this.route(endpoints_js_1.Endpoints.BannerColors));
    }
    cosmetics(options = {}) {
        const params = { language: options.language ?? this.language, responseFlags: this.parseFlags(options) };
        switch (options.cosmeticType) {
            case 'new': {
                return this.fetch(this.route(endpoints_js_1.Endpoints.NewCosmetics, params));
            }
            case 'br': {
                return this.fetch(this.route(endpoints_js_1.Endpoints.BRCosmetics, params));
            }
            case 'tracks': {
                return this.fetch(this.route(endpoints_js_1.Endpoints.Tracks, params));
            }
            case 'cars': {
                return this.fetch(this.route(endpoints_js_1.Endpoints.Cars, params));
            }
            case 'instruments': {
                return this.fetch(this.route(endpoints_js_1.Endpoints.Instruments, params));
            }
            case 'lego': {
                return this.fetch(this.route(endpoints_js_1.Endpoints.LEGO, params));
            }
            case 'legoKits': {
                return this.fetch(this.route(endpoints_js_1.Endpoints.LEGOKits, params));
            }
            case 'beans': {
                return this.fetch(this.route(endpoints_js_1.Endpoints.Beans, params));
            }
            default: {
                return this.fetch(this.route(endpoints_js_1.Endpoints.AllCosmetics, params));
            }
        }
    }
    /**
     * Finds the first BR cosmetic that matches provided search parameters.
     *
     * @param options - Options for finding a BR cosmetic
     * @returns A BR cosmetic that matches the search parameters
     */
    brCosmeticsSearch(options) {
        const language = options.language ?? this.language;
        return this.fetch(options.id === undefined
            ? this.route(endpoints_js_1.Endpoints.BRCosmeticSearch, { ...options, language })
            : this.route(endpoints_js_1.Endpoints.BRCosmeticById.replace('{cosmetic-id}', options.id), { language }));
    }
    /**
     * Finds all BR cosmetics that match provided search parameters.
     *
     * @param options - Options for finding BR cosmetics
     * @returns All BR cosmetics that match the search parameters
     */
    brCosmeticsSearchAll(options) {
        const language = options.language ?? this.language;
        return this.fetch(options.id === undefined
            ? this.route(endpoints_js_1.Endpoints.BRCosmeticsSearchAll, { ...options, language })
            : this.route(`${endpoints_js_1.Endpoints.BRCosmeticsSearchByIds}`, { id: options.id, language }, true));
    }
    /**
     * Fetches information about a creator code.
     *
     * @param name - The creator code's name
     * @returns Information about the creator code
     */
    creatorCode(name) {
        return this.fetch(this.route(endpoints_js_1.Endpoints.CreatorCode, { name }));
    }
    /**
     * Fetches information about the current Battle Royale map.
     *
     * @param language - The language for the returned data
     * @returns Information about the current map
     */
    map(language = this.language) {
        return this.fetch(this.route(endpoints_js_1.Endpoints.Map, { language }));
    }
    news(options = {}) {
        const params = { language: options.language ?? this.language };
        return options.mode === undefined
            ? this.fetch(this.route(endpoints_js_1.Endpoints.News, params))
            : this.fetch(this.route({
                br: endpoints_js_1.Endpoints.BRNews,
                stw: endpoints_js_1.Endpoints.STWNews,
                creative: endpoints_js_1.Endpoints.CreativeNews
            }[options.mode], params));
    }
    playlists(options = {}) {
        const params = { language: options.language ?? this.language };
        return options.id === undefined
            ? this.fetch(this.route(endpoints_js_1.Endpoints.Playlists, params))
            : this.fetch(this.route(endpoints_js_1.Endpoints.PlaylistById.replace('{playlist-id}', options.id), params));
    }
    /**
     * Fetches the current item shop.
     *
     * @param options - Options for the language and optional properties to include in the response
     * @returns The item shop
     */
    shop(options = {}) {
        const params = { language: options.language ?? this.language, responseFlags: this.parseFlags(options) };
        return this.fetch(this.route(endpoints_js_1.Endpoints.Shop, params));
    }
    /**
     * Fetches a user's stats by name or id.
     *
     * @param options - Options for fetching stats
     * @returns The user's stats
     */
    stats(options) {
        const key = options.key ?? this.key;
        if (key === null)
            throw new TypeError('Client#stats() requires an authorization key passed into the Client constructor options. You may request one at https://dash.fortnite-api.com/account');
        const hasName = 'name' in options;
        const hasId = 'id' in options;
        if (!hasName && !hasId)
            throw new TypeError('Neither the "name" nor the "id" property of the Client#stats() argument were provided');
        else if (hasName && hasId)
            throw new TypeError('The "name" and "id" properties of the Client#stats() argument are mutually exclusive');
        else if (hasId && 'accountType' in options)
            throw new TypeError('The "id" and "accountType" properties of the Client#stats() argument are mutually exclusive');
        let route;
        if (hasName) {
            route = this.route(endpoints_js_1.Endpoints.BRStats, options);
        }
        else {
            const params = {};
            if (options.timeWindow !== undefined)
                params.timeWindow = options.timeWindow;
            if (options.image !== undefined)
                params.image = options.image;
            route = this.route(endpoints_js_1.Endpoints.BRStatsByAccountId.replace('{accountId}', options.id), params);
        }
        return this.fetch(route, key);
    }
}
exports.Client = Client;
